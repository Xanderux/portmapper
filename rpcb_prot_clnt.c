/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <memory.h> /* for memset */
#include "rpcb_prot.h"

/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { 25, 0 };

bool_t *
rpcbproc_set_3(rpcb *argp, CLIENT *clnt)
{
	static bool_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, RPCBPROC_SET,
		(xdrproc_t) xdr_rpcb, (caddr_t) argp,
		(xdrproc_t) xdr_bool, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

bool_t *
rpcbproc_unset_3(rpcb *argp, CLIENT *clnt)
{
	static bool_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, RPCBPROC_UNSET,
		(xdrproc_t) xdr_rpcb, (caddr_t) argp,
		(xdrproc_t) xdr_bool, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

char **
rpcbproc_getaddr_3(rpcb *argp, CLIENT *clnt)
{
	static char *clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, RPCBPROC_GETADDR,
		(xdrproc_t) xdr_rpcb, (caddr_t) argp,
		(xdrproc_t) xdr_wrapstring, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

rpcblist_ptr *
rpcbproc_dump_3(void *argp, CLIENT *clnt)
{
	static rpcblist_ptr clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, RPCBPROC_DUMP,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_rpcblist_ptr, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

rpcb_rmtcallres *
rpcbproc_callit_3(rpcb_rmtcallargs *argp, CLIENT *clnt)
{
	static rpcb_rmtcallres clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, RPCBPROC_CALLIT,
		(xdrproc_t) xdr_rpcb_rmtcallargs, (caddr_t) argp,
		(xdrproc_t) xdr_rpcb_rmtcallres, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

u_int *
rpcbproc_gettime_3(void *argp, CLIENT *clnt)
{
	static u_int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, RPCBPROC_GETTIME,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_u_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

netbuf *
rpcbproc_uaddr2taddr_3(char **argp, CLIENT *clnt)
{
	static netbuf clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, RPCBPROC_UADDR2TADDR,
		(xdrproc_t) xdr_wrapstring, (caddr_t) argp,
		(xdrproc_t) xdr_netbuf, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

char **
rpcbproc_taddr2uaddr_3(netbuf *argp, CLIENT *clnt)
{
	static char *clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, RPCBPROC_TADDR2UADDR,
		(xdrproc_t) xdr_netbuf, (caddr_t) argp,
		(xdrproc_t) xdr_wrapstring, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

bool_t *
rpcbproc_set_4(rpcb *argp, CLIENT *clnt)
{
	static bool_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, RPCBPROC_SET,
		(xdrproc_t) xdr_rpcb, (caddr_t) argp,
		(xdrproc_t) xdr_bool, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

bool_t *
rpcbproc_unset_4(rpcb *argp, CLIENT *clnt)
{
	static bool_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, RPCBPROC_UNSET,
		(xdrproc_t) xdr_rpcb, (caddr_t) argp,
		(xdrproc_t) xdr_bool, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

char **
rpcbproc_getaddr_4(rpcb *argp, CLIENT *clnt)
{
	static char *clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, RPCBPROC_GETADDR,
		(xdrproc_t) xdr_rpcb, (caddr_t) argp,
		(xdrproc_t) xdr_wrapstring, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

rpcblist_ptr *
rpcbproc_dump_4(void *argp, CLIENT *clnt)
{
	static rpcblist_ptr clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, RPCBPROC_DUMP,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_rpcblist_ptr, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

rpcb_rmtcallres *
rpcbproc_bcast_4(rpcb_rmtcallargs *argp, CLIENT *clnt)
{
	static rpcb_rmtcallres clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, RPCBPROC_BCAST,
		(xdrproc_t) xdr_rpcb_rmtcallargs, (caddr_t) argp,
		(xdrproc_t) xdr_rpcb_rmtcallres, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

u_int *
rpcbproc_gettime_4(void *argp, CLIENT *clnt)
{
	static u_int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, RPCBPROC_GETTIME,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_u_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

netbuf *
rpcbproc_uaddr2taddr_4(char **argp, CLIENT *clnt)
{
	static netbuf clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, RPCBPROC_UADDR2TADDR,
		(xdrproc_t) xdr_wrapstring, (caddr_t) argp,
		(xdrproc_t) xdr_netbuf, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

char **
rpcbproc_taddr2uaddr_4(netbuf *argp, CLIENT *clnt)
{
	static char *clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, RPCBPROC_TADDR2UADDR,
		(xdrproc_t) xdr_netbuf, (caddr_t) argp,
		(xdrproc_t) xdr_wrapstring, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

char **
rpcbproc_getversaddr_4(rpcb *argp, CLIENT *clnt)
{
	static char *clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, RPCBPROC_GETVERSADDR,
		(xdrproc_t) xdr_rpcb, (caddr_t) argp,
		(xdrproc_t) xdr_wrapstring, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

rpcb_rmtcallres *
rpcbproc_indirect_4(rpcb_rmtcallargs *argp, CLIENT *clnt)
{
	static rpcb_rmtcallres clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, RPCBPROC_INDIRECT,
		(xdrproc_t) xdr_rpcb_rmtcallargs, (caddr_t) argp,
		(xdrproc_t) xdr_rpcb_rmtcallres, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

rpcb_entry_list_ptr *
rpcbproc_getaddrlist_4(rpcb *argp, CLIENT *clnt)
{
	static rpcb_entry_list_ptr clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, RPCBPROC_GETADDRLIST,
		(xdrproc_t) xdr_rpcb, (caddr_t) argp,
		(xdrproc_t) xdr_rpcb_entry_list_ptr, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

rpcb_stat *
rpcbproc_getstat_4(void *argp, CLIENT *clnt)
{
	static rpcb_stat_byvers clnt_res;

	memset((char *)clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, RPCBPROC_GETSTAT,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_rpcb_stat_byvers, (caddr_t) clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (clnt_res);
}
